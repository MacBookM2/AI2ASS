// Generated by CoffeeScript 1.3.3
var byLayer, collectPaths, cubic, doc, drawCom, drawStrs, fixCoords, handleGray, handleRGB, linear, manageColor, scl, zeroPad;

app.userInteractionLevel = UserInteractionLevel.DISPLAYALERTS;

doc = app.activeDocument;

if (doc.documentColorSpace === DocumentColorSpace.CMYK) {
  alert("your colorspace needs to be RGB if you want colors.");
}

scl = parseInt(prompt("Scale by 2^(n-1) (minimum 1)", 1));

drawStrs = {};

drawCom = 0;

fixCoords = function(coordArr) {
  var org;
  org = doc.rulerOrigin;
  coordArr[0] = Math.round((coordArr[0] + org[0]) * Math.pow(2, scl - 1));
  coordArr[1] = Math.round((doc.height - (org[1] + coordArr[1])) * Math.pow(2, scl - 1));
  return coordArr.join(" ");
};

linear = function(currPoint) {
  var drawing;
  drawing = "";
  if (drawCom !== 1) {
    drawCom = 1;
    drawing = "l ";
  }
  return drawing += fixCoords(currPoint.anchor) + " ";
};

cubic = function(currPoint, prevPoint) {
  var drawing;
  drawing = "";
  if (drawCom !== 2) {
    drawCom = 2;
    drawing = "b ";
  }
  return drawing += fixCoords(prevPoint.rightDirection, scl) + " " + fixCoords(currPoint.leftDirection, scl) + " " + fixCoords(currPoint.anchor, scl) + " ";
};

byLayer = function() {
  var currLayer, herp, _i, _ref;
  for (currLayer = _i = _ref = doc.layers.length - 1; _i >= 0; currLayer = _i += -1) {
    currLayer = doc.layers[currLayer].name;
    if (drawStrs[currLayer]) {
      herp = prompt("COPY THIS", drawStrs[currLayer].replace(/[ ]$/, ""), "copy it");
    }
  }
  return herp = null;
};

zeroPad = function(num) {
  if (num < 16) {
    return "0" + num.toString(16);
  }
  return num.toString(16);
};

handleGray = function(theColor) {
  var pct;
  pct = theColor.gray;
  pct = Math.round(pct * 255 / 100);
  return ("&H" + zeroPad(pct) + zeroPad(pct) + zeroPad(pct) + "&").toUpperCase();
};

handleRGB = function(theColor) {
  var b, g, r;
  r = Math.round(theColor.red);
  g = Math.round(theColor.green);
  b = Math.round(theColor.blue);
  return ("&H" + zeroPad(b) + zeroPad(g) + zeroPad(r) + "&").toUpperCase();
};

manageColor = function(currPath, field, ASSField) {
  var fmt;
  fmt = "";
  switch (currPath[field].typename) {
    case "RGBColor":
      fmt = handleRGB(currPath[field]);
      break;
    case "GrayColor":
      fmt = handleGray(currPath[field]);
      break;
    case "NoColor":
      switch (field) {
        case "fillColor":
          return "\\" + ASSField + "a&HFF&";
        case "strokeColor":
          return "\\bord0";
      }
      break;
    default:
      return "";
  }
  return "\\" + ASSField + "c" + fmt;
};

collectPaths = function(callback) {
  var currPath, currPoint, fgc, j, lname, points, prevPoint, sc, _i, _j, _len, _ref, _ref1;
  _ref = doc.pathItems;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    currPath = _ref[_i];
    lname = currPath.layer.name;
    fgc = manageColor(currPath, "fillColor", 1);
    sc = manageColor(currPath, "strokeColor", 3);
    if (!drawStrs[lname]) {
      drawStrs[lname] = "{" + fgc + sc + "\\p" + scl + "}";
    }
    points = currPath.pathPoints;
    if (points.length > 0) {
      drawCom = 0;
      drawStrs[lname] += "m " + fixCoords(points[0].anchor, scl) + " ";
      for (j = _j = 1, _ref1 = points.length; _j < _ref1; j = _j += 1) {
        currPoint = points[j];
        prevPoint = points[j - 1];
        if (currPoint.pointType === PointType.CORNER && prevPoint.pointType === PointType.CORNER) {
          drawStrs[lname] += linear(currPoint);
        } else {
          drawStrs[lname] += cubic(currPoint, prevPoint);
        }
      }
      prevPoint = points[points.length - 1];
      currPoint = points[0];
      if (currPoint.pointType === PointType.SMOOTH || prevPoint.pointType === PointType.SMOOTH) {
        drawStrs[lname] += cubic(currPoint, prevPoint);
      }
    }
  }
  return callback();
};

collectPaths(byLayer);
