// Generated by CoffeeScript 1.6.3
#targetengine session;
var fuckThis, gobutton, input, label, slider, textCtrl, value, win;

win = new Window("palette", "Export ASS", void 0, {
  resizeable: true
});

input = win.add("group");

input.orientation = "row";

label = input.add('statictext', void 0, 'Scale Factor: ');

label.graphics.font = "Comic Sans MS:12";

value = input.add('edittext {text: 1, characters: 2, justify: "center", active: true}');

value.graphics.font = "Comic Sans MS:12";

slider = input.add('slider', void 0, 1, 1, 11);

slider.onChanging = function() {
  return value.text = Math.round(slider.value);
};

value.onChanging = function() {
  return slider.value = Number(value.text);
};

textCtrl = win.add("edittext", [0, 0, 250, 80], "", {
  multiline: true
});

textCtrl.graphics.font = "Comic Sans MS:12";

textCtrl.text = "have ass will travel";

gobutton = win.add("button", void 0, "Export Active Layer");

gobutton.graphics.font = "Comic Sans MS:12";

gobutton.onClick = function() {
  var bt;
  bt = new BridgeTalk;
  bt.target = "illustrator";
  bt.body = "(" + (fuckThis.toString()) + ")(" + value.text + ");";
  bt.onResult = function(result) {
    return textCtrl.text = result.body.replace(/\\\\/g, "\\");
  };
  bt.onError = function(err) {
    return alert("" + err.body + " (" + a.headers["Error-Code"] + ")");
  };
  return bt.send();
};

fuckThis = function(scl) {
  var checkLinear, collectPaths, cubic, currLayer, doc, drawCom, drawStr, fixCoords, handleGray, handleRGB, linear, manageColor, zeroPad;
  app.userInteractionLevel = UserInteractionLevel.DISPLAYALERTS;
  doc = app.activeDocument;
  currLayer = doc.activeLayer;
  if (doc.documentColorSpace === DocumentColorSpace.CMYK) {
    alert("your colorspace needs to be RGB if you want colors.");
  }
  drawStr = "";
  drawCom = 0;
  fixCoords = function(coordArr) {
    var org;
    org = doc.rulerOrigin;
    coordArr[0] = Math.round((coordArr[0] + org[0]) * Math.pow(2, scl - 1));
    coordArr[1] = Math.round((doc.height - (org[1] + coordArr[1])) * Math.pow(2, scl - 1));
    return coordArr.join(" ");
  };
  checkLinear = function(currPoint, prevPoint) {
    var p1, p2;
    p1 = prevPoint.anchor[0] === prevPoint.rightDirection[0] && prevPoint.anchor[1] === prevPoint.rightDirection[1];
    p2 = currPoint.anchor[0] === currPoint.leftDirection[0] && currPoint.anchor[1] === currPoint.leftDirection[1];
    return p1 && p2;
  };
  linear = function(currPoint) {
    var drawing;
    drawing = "";
    if (drawCom !== 1) {
      drawCom = 1;
      drawing = " l";
    }
    return drawing += " " + fixCoords(currPoint.anchor);
  };
  cubic = function(currPoint, prevPoint) {
    var drawing;
    drawing = "";
    if (drawCom !== 2) {
      drawCom = 2;
      drawing = " b";
    }
    return drawing += " " + fixCoords(prevPoint.rightDirection, scl) + " " + fixCoords(currPoint.leftDirection, scl) + " " + fixCoords(currPoint.anchor, scl);
  };
  zeroPad = function(num) {
    if (num < 16) {
      return "0" + num.toString(16);
    }
    return num.toString(16);
  };
  handleGray = function(theColor) {
    var pct;
    pct = theColor.gray;
    pct = Math.round((100 - pct) * 255 / 100);
    return ("&H" + zeroPad(pct) + zeroPad(pct) + zeroPad(pct) + "&").toUpperCase();
  };
  handleRGB = function(theColor) {
    var b, g, r;
    r = Math.round(theColor.red);
    g = Math.round(theColor.green);
    b = Math.round(theColor.blue);
    return ("&H" + zeroPad(b) + zeroPad(g) + zeroPad(r) + "&").toUpperCase();
  };
  manageColor = function(currPath, field, ASSField) {
    var fmt;
    fmt = "";
    switch (currPath[field].typename) {
      case "RGBColor":
        fmt = handleRGB(currPath[field]);
        break;
      case "GrayColor":
        fmt = handleGray(currPath[field]);
        break;
      case "NoColor":
        switch (field) {
          case "fillColor":
            return "\\" + ASSField + "a&HFF&";
          case "strokeColor":
            return "";
        }
        break;
      default:
        return "";
    }
    return "\\" + ASSField + "c" + fmt;
  };
  collectPaths = function() {
    var currPath, currPoint, fgc, j, points, prevPoint, sc, _i, _j, _len, _ref, _ref1;
    alert("" + doc.pathItems.length);
    _ref = doc.pathItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      currPath = _ref[_i];
      if (currPath.layer.name === currLayer.name) {
        if (drawStr.length === 0) {
          fgc = manageColor(currPath, "fillColor", 1);
          sc = manageColor(currPath, "strokeColor", 3);
          drawStr = "{" + fgc + sc + "\\p" + scl + "}";
        }
        points = currPath.pathPoints;
        if (points.length > 0) {
          drawCom = 0;
          drawStr += "m " + fixCoords(points[0].anchor, scl);
          for (j = _j = 1, _ref1 = points.length; _j < _ref1; j = _j += 1) {
            currPoint = points[j];
            prevPoint = points[j - 1];
            if (checkLinear(currPoint, prevPoint)) {
              drawStr += linear(currPoint);
            } else {
              drawStr += cubic(currPoint, prevPoint);
            }
          }
          prevPoint = points[points.length - 1];
          currPoint = points[0];
          if (!checkLinear(currPoint, prevPoint)) {
            drawStr += cubic(currPoint, prevPoint);
          }
        }
      }
    }
    return drawStr;
  };
  return collectPaths();
};

win.show();
