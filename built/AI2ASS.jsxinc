// Generated by CoffeeScript 1.7.1
var ai2assBackend;

ai2assBackend = function(options) {
  var ASS_createDrawingFromPoints, ASS_cubic, ASS_fixCoords, ASS_linear, CG_createDrawingFromPoints, CG_cubic, CG_fixCoords, CG_linear, allThePaths, checkLinear, currLayer, doc, drawCom, handleGray, handleRGB, manageColor, methods, org, output, pWin, recursePageItem, zeroPad;
  pWin = new Window("palette");
  pWin.pBar = pWin.add("progressbar", void 0, 0, 1000);
  pWin.pBar.preferredSize = [300, 15];
  app.userInteractionLevel = UserInteractionLevel.DISPLAYALERTS;
  doc = app.activeDocument;
  org = doc.rulerOrigin;
  currLayer = doc.activeLayer;
  drawCom = 0;
  output = {
    str: "",
    lastFill: "",
    lastStroke: "",
    append: function(toAppend) {
      return this.str += toAppend;
    },
    init: function(path) {
      this.lastFill = manageColor(path, "fillColor", 1);
      this.lastStroke = manageColor(path, "strokeColor", 3);
      return this.append(this.prefix());
    },
    split: options.split || function(path) {
      var fillChange, fillColor, strokeChange, strokeColor;
      fillColor = manageColor(path, "fillColor", 1);
      strokeColor = manageColor(path, "strokeColor", 3);
      fillChange = fillColor !== this.lastFill;
      strokeChange = strokeColor !== this.lastStroke;
      if (fillChange || strokeChange) {
        this.lastFill = fillColor;
        this.lastStroke = strokeColor;
        return this.append("" + (this.suffix()) + "\n" + (this.prefix()));
      }
    },
    appendPath: function(path) {
      if (!(path.hidden || path.guides || path.clipping || !(path.stroked || path.filled))) {
        this.split(path);
        return this.append(ASS_createDrawingFromPoints(path.pathPoints));
      }
    },
    prefix: function() {
      return "{\\an7\\pos(0,0)" + this.lastStroke + this.lastFill + "\\p1}";
    },
    suffix: function() {
      return "{\\p0}";
    },
    merge: function() {
      return this.str;
    }
  };
  switch (options.wrapper) {
    case "clip":
      output.prefix = function() {
        return "\\clip(";
      };
      output.suffix = function() {
        return ")";
      };
      break;
    case "iclip":
      output.prefix = function() {
        return "\\iclip(";
      };
      output.suffix = function() {
        return ")";
      };
      break;
    case "bare":
      output.prefix = function() {
        return "";
      };
      output.suffix = function() {
        return "";
      };
  }
  if (doc.documentColorSpace === DocumentColorSpace.CMYK) {
    alert("Your colorspace needs to be RGB if you want colors.");
  }
  ASS_fixCoords = function(coordArr) {
    coordArr[0] = Math.round((coordArr[0] + org[0]) * 100) / 100;
    coordArr[1] = Math.round((doc.height - (org[1] + coordArr[1])) * 100) / 100;
    return coordArr.join(" ");
  };
  CG_fixCoords = function(coordArr) {
    coordArr[0] = Math.round((coordArr[0] + org[0]) * 100) / 100;
    coordArr[1] = Math.round((coordArr[1] + org[1]) * 100) / 100;
    return coordArr.join(", ");
  };
  checkLinear = function(currPoint, prevPoint) {
    var p1, p2;
    p1 = prevPoint.anchor[0] === prevPoint.rightDirection[0] && prevPoint.anchor[1] === prevPoint.rightDirection[1];
    p2 = currPoint.anchor[0] === currPoint.leftDirection[0] && currPoint.anchor[1] === currPoint.leftDirection[1];
    return p1 && p2;
  };
  ASS_linear = function(currPoint) {
    var drawing;
    drawing = "";
    if (drawCom !== 1) {
      drawCom = 1;
      drawing = "l ";
    }
    return drawing += "" + (ASS_fixCoords(currPoint.anchor)) + " ";
  };
  CG_linear = function(currPoint) {
    return "CGContextAddLineToPoint(ctx, " + (CG_fixCoords(currPoint.anchor)) + ");\n";
  };
  ASS_cubic = function(currPoint, prevPoint) {
    var drawing;
    drawing = "";
    if (drawCom !== 2) {
      drawCom = 2;
      drawing = "b ";
    }
    return drawing += "" + (ASS_fixCoords(prevPoint.rightDirection)) + " " + (ASS_fixCoords(currPoint.leftDirection)) + " " + (ASS_fixCoords(currPoint.anchor)) + " ";
  };
  CG_cubic = function(currPoint, prevPoint) {
    return "CGContextAddCurveToPoint(ctx, " + (CG_fixCoords(prevPoint.rightDirection)) + ", " + (CG_fixCoords(currPoint.leftDirection)) + ", " + (CG_fixCoords(currPoint.anchor)) + ");\n";
  };
  zeroPad = function(num) {
    if (num < 16) {
      return "0" + (num.toString(16));
    } else {
      return num.toString(16);
    }
  };
  handleGray = function(theColor) {
    var pct;
    pct = theColor.gray;
    pct = Math.round((100 - pct) * 255 / 100);
    return ("&H" + (zeroPad(pct)) + (zeroPad(pct)) + (zeroPad(pct)) + "&").toUpperCase();
  };
  handleRGB = function(theColor) {
    var b, g, r;
    r = Math.round(theColor.red);
    g = Math.round(theColor.green);
    b = Math.round(theColor.blue);
    return ("&H" + (zeroPad(b)) + (zeroPad(g)) + (zeroPad(r)) + "&").toUpperCase();
  };
  manageColor = function(currPath, field, ASSField) {
    var fmt;
    fmt = "";
    switch (currPath[field].typename) {
      case "RGBColor":
        fmt = handleRGB(currPath[field]);
        break;
      case "GrayColor":
        fmt = handleGray(currPath[field]);
        break;
      case "NoColor":
        switch (field) {
          case "fillColor":
            return "\\" + ASSField + "a&HFF&";
          case "strokeColor":
            return "";
        }
        break;
      default:
        return "";
    }
    return "\\" + ASSField + "c" + fmt;
  };
  ASS_createDrawingFromPoints = function(pathPoints) {
    var currPoint, drawStr, j, prevPoint, _i, _ref;
    drawStr = "";
    if (pathPoints.length > 0) {
      drawCom = 0;
      drawStr += "m " + (ASS_fixCoords(pathPoints[0].anchor)) + " ";
      for (j = _i = 1, _ref = pathPoints.length; _i < _ref; j = _i += 1) {
        currPoint = pathPoints[j];
        prevPoint = pathPoints[j - 1];
        if (checkLinear(currPoint, prevPoint)) {
          drawStr += ASS_linear(currPoint);
        } else {
          drawStr += ASS_cubic(currPoint, prevPoint);
        }
      }
      prevPoint = pathPoints[pathPoints.length - 1];
      currPoint = pathPoints[0];
      if (!checkLinear(currPoint, prevPoint)) {
        drawStr += ASS_cubic(currPoint, prevPoint);
      }
      return drawStr;
    }
    return "";
  };
  CG_createDrawingFromPoints = function(pathPoints) {
    var currPoint, drawStr, j, prevPoint, _i, _ref;
    drawStr = "";
    if (pathPoints.length > 0) {
      drawStr += "CGContextMoveToPoint(ctx, " + (CG_fixCoords(pathPoints[0].anchor)) + ");\n";
      for (j = _i = 1, _ref = pathPoints.length; _i < _ref; j = _i += 1) {
        currPoint = pathPoints[j];
        prevPoint = pathPoints[j - 1];
        if (checkLinear(currPoint, prevPoint)) {
          drawStr += CG_linear(currPoint);
        } else {
          drawStr += CG_cubic(currPoint, prevPoint);
        }
      }
      prevPoint = pathPoints[pathPoints.length - 1];
      currPoint = pathPoints[0];
      if (!checkLinear(currPoint, prevPoint)) {
        drawStr += CG_cubic(currPoint, prevPoint);
      }
      return drawStr;
    }
    return "";
  };
  allThePaths = [];
  recursePageItem = function(pageItem) {
    var path, subPageItem, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
    switch (pageItem.typename) {
      case "CompoundPathItem":
        _ref = pageItem.pathItems;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _results.push(recursePageItem(path));
        }
        return _results;
        break;
      case "GroupItem":
        _ref1 = pageItem.pageItems;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          subPageItem = _ref1[_j];
          _results1.push(recursePageItem(subPageItem));
        }
        return _results1;
        break;
      case "PathItem":
        return allThePaths.push(pageItem);
      default:
        return alert(pageItem.typename);
    }
  };
  methods = {
    common: function() {
      var i, path, _i, _len;
      pWin.show();
      output.init(allThePaths[0]);
      for (i = _i = 0, _len = allThePaths.length; _i < _len; i = ++_i) {
        path = allThePaths[i];
        output.appendPath(path);
        pWin.pBar.value = Math.ceil(i * 1000 / allThePaths.length);
        pWin.update();
      }
      output.append(output.suffix());
      pWin.close();
      return output.merge();
    },
    collectActiveLayer: function() {
      var pageItem, _i, _len, _ref;
      _ref = currLayer.pageItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pageItem = _ref[_i];
        recursePageItem(pageItem, output);
      }
      return this.common();
    },
    CG_collectActiveLayer: function() {
      var pageItem, _i, _len, _ref;
      output.appendPath = function(path) {
        if (!(path.hidden || path.guides || path.clipping || !(path.stroked || path.filled))) {
          return this.append(CG_createDrawingFromPoints(path.pathPoints));
        }
      };
      _ref = currLayer.pageItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pageItem = _ref[_i];
        recursePageItem(pageItem, output);
      }
      return this.common();
    },
    collectInnerShadow: function() {
      var currPath, glyphPaths, glyphStr, group, outerGroup, outlinePaths, outlineStr, outputStr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      outputStr = "";
      if (currLayer.groupItems.length === 0) {
        return "Layer formatting not as expected.";
      }
      _ref = currLayer.groupItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        outerGroup = _ref[_i];
        if (outerGroup.groupItems.length === 0) {
          return "Layer formatting not as expected.";
        }
        _ref1 = outerGroup.groupItems;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          if (group.compoundPathItems.length === 0) {
            return "Layer formatting not as expected.";
          }
          outlinePaths = group.compoundPathItems[0].pathItems;
          outlineStr = "";
          glyphPaths = group.compoundPathItems[1].pathItems;
          glyphStr = "";
          for (_k = 0, _len2 = glyphPaths.length; _k < _len2; _k++) {
            currPath = glyphPaths[_k];
            glyphStr += ASS_createDrawingFromPoints(currPath.pathPoints);
          }
          for (_l = 0, _len3 = outlinePaths.length; _l < _len3; _l++) {
            currPath = outlinePaths[_l];
            outlineStr += ASS_createDrawingFromPoints(currPath.pathPoints);
          }
          glyphStr = glyphStr.slice(0, -1);
          outlineStr = "{\\clip(" + glyphStr + ")\\p1}" + outlineStr.slice(0, -1);
          glyphStr = "{\\p1}" + glyphStr;
          outputStr += "" + glyphStr + "\n" + outlineStr + "\n";
        }
      }
      return ("{innerShadow}\n" + outputStr).slice(0, -2);
    },
    collectAllLayers: function() {
      allThePaths = doc.pathItems;
      return this.common();
    }
  };
  return methods[options.method]();
};
